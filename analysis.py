# -*- coding: utf-8 -*-
"""pow_ha.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13u77pkrdvCOrxZALYtXCOGX8tNlF4LFZ
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sentiment_classifier import get_ed8_emotions

speeches = pd.read_csv("./blob/speeches_filtered.csv")
factions = pd.read_csv("./blob/factions.csv")

speeches = speeches[speeches['positionShort'] != "Presidium of Parliament"]
speeches = speeches[speeches['speechContent'].str.split().str.len() > 80]

def assign_role(row):
    # Sonderfall: technische Reden der Bundesregierung (factionId = -1)
    if row['factionId'] == -1:
        return 'Regierung'

    # Logik nach Legislaturperiode und Fraktionsk√ºrzel
    if row['electoralTerm'] == 16 and row['abbreviation'] in ['CDU/CSU', 'SPD']:
        return 'Regierung'
    elif row['electoralTerm'] == 17 and row['abbreviation'] in ['CDU/CSU', 'FDP']:
        return 'Regierung'
    elif row['electoralTerm'] == 18 and row['abbreviation'] in ['CDU/CSU', 'SPD']:
        return 'Regierung'
    elif row['electoralTerm'] == 19 and row['abbreviation'] in ['CDU/CSU', 'SPD']:
        return 'Regierung'
    else:
        return 'Opposition'

speeches = speeches.rename(columns={'id': 'speech_id'})
df = speeches.merge(factions, left_on="factionId", right_on = "id")
df.drop("id", axis=1, inplace=True)
df["date"] = pd.to_datetime(df["date"], format="%Y-%m-%d", errors="coerce")
df["year"] = pd.to_datetime(df["date"]).dt.year
df["role"] = df.apply(assign_role, axis=1)
df["speechWords"] = df["speechContent"].str.split().str.len()

results = df["speechContent"].astype(str).apply(get_ed8_emotions)
results_df = pd.DataFrame(results.tolist())

# üß∑ Zusammenf√ºhren und speichern
df_final = pd.concat([df, results_df], axis=1)
df_final.to_csv("speeches_with_ed8.csv", index=False)

# Analyse der Daten
df = pd.read_csv("speeches_with_ed8.csv")
df = df[df['year'] >= 2006]
df.head(50)

df.info()

"""# ***Verk√ºrzung Analyse***"""

## F√ºr Verk√ºzungs√ºberpr√ºfung
df_short = df[df['speechContent'].str.split().str.len() > 120]

avg_words = df_short.groupby(["year", "role"])["speechWords"].mean().reset_index()

# Plot
plt.figure(figsize=(12, 6))
sns.lineplot(data=avg_words, x="year", y="speechWords", hue="role", marker="o", errorbar="sd")

# Titel und Achsen
plt.title("Durchschnittliche Wortanzahl von Bundestagsreden pro Jahr")
plt.xlabel("Jahr")
plt.ylabel("Wortanzahl")
plt.grid(True)
plt.legend(title="Rolle")
plt.tight_layout()
plt.show()

avg_tokens = df_short.groupby(["year", "role"])["terms"].mean().reset_index()

# Plot
plt.figure(figsize=(12, 6))
sns.lineplot(data=avg_words, x="year", y="terms", hue="role", marker="o", errorbar="sd")

# Titel und Achsen
plt.title("Durchschnittliche Anzahl an benutzten W√∂rtern in Bundestagsreden pro Jahr")
plt.xlabel("Jahr")
plt.ylabel("Wortanzahl")
plt.grid(True)
plt.legend(title="Rolle")
plt.tight_layout()
plt.show()

"""# **Emotions Analyse**
√úberlegung statt dem Jahr die Wahlperiode als Zeitreferenz zu nutzen.
"""

df.columns
def emotion_intensity(row):
  emo_score = 0
  emotions = ['anger', 'fear', 'sadness', 'enthusiasm', 'pride', 'hope']
  for emotion in emotions:
    emo_score += row[emotion]
  return emo_score

df['emotional_intensitiy'] = df.apply(emotion_intensity, axis=1)
df['emotion_intensity_norm'] = df['emotional_intensitiy'] / df['terms']

emotions = ["anger.norm", "fear.norm", "disgust.norm", "sadness.norm",
            "joy.norm", "hope.norm", "enthusiasm.norm", "pride.norm"]

# Iteration √ºber alle Emotionen
for emotion in emotions:
    plt.figure(figsize=(12, 6))

    # Gruppieren und Mittelwert berechnen
    avg_emotion = df.groupby(["year", "role"])[emotion].mean().reset_index()

    # Plot
    sns.lineplot(data=avg_emotion, x="year", y=emotion, hue="role", marker="o", ci="sd")

    # Achsen & Titel
    plt.title(f"Durchschnittliche Auspr√§gung der Emotion: {emotion.replace('.norm','').capitalize()} pro Jahr")
    plt.xlabel("Jahr")
    plt.ylabel("Normierte H√§ufigkeit")
    plt.grid(True)
    plt.legend(title="Rolle")
    plt.tight_layout()
    plt.show()

avg_emotion_intensity = df.groupby(["year", "role"])["emotion_intensity_norm"].mean().reset_index()

# Plot
plt.figure(figsize=(12, 6))
sns.lineplot(data=avg_emotion_intensity, x="year", y="emotion_intensity_norm", hue="role", marker="o", ci="sd")

# Titel und Achsen
plt.title("Durchschnittliche Emotionsintensit√§t von Bundestagsreden pro Jahr")
plt.xlabel("Jahr")
plt.ylabel("Emotionsintensit√§t")
plt.grid(True)
plt.legend(title="Rolle")
plt.tight_layout()
plt.show()

df_filtered = df[~df['abbreviation'].isin(['Fraktionslos', 'not found'])]
df_filtered = df_filtered[df_filtered['year'] >= 2006]

colors = {
    'DIE LINKE.': 'pink',
    'SPD': 'red',
    'Gr√ºne': 'green',
    'FDP': 'yellow',
    'AfD': 'blue',
    'CDU/CSU': 'black'
}

# Plot
emotions = ["anger.norm", "fear.norm", "disgust.norm", "sadness.norm",
            "joy.norm", "hope.norm", "enthusiasm.norm", "pride.norm"]

# Iteration √ºber alle Emotionen
for emotion in emotions:
    plt.figure(figsize=(12, 6))

    avg_anger_score = df_filtered.groupby(["year", "abbreviation"])[emotion].mean().reset_index()

    sns.lineplot(data=avg_anger_score, x="year", y=emotion, hue="abbreviation", marker="o", errorbar="sd", palette=colors)

    # Titel und Achsen
    plt.title(f"Durchschnittliche Auspr√§gung der Emotion: {emotion.replace('.norm','').capitalize()} pro Jahr")
    plt.xlabel("Jahr")
    plt.ylabel("Normierte H√§ufigkeit")
    plt.grid(True)
    plt.legend(title="Rolle")
    plt.tight_layout()
    plt.show()